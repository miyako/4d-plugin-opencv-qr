/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-opencv-qr.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : opencv-qr
 #	author : miyako
 #	2022/06/03
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-opencv-qr.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- opencv-qr
            
			case 1 :
				opencv_decode_qrcode(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

#define CONVERT_PICTURE  (1002)
#define PICTURE_PROPERTIES (457)

#if VERSIONMAC
    typedef CGImageRef Image;
#else
    typedef Gdiplus::Bitmap *Image;
#endif

static void imageToMat(Image image, cv::Mat& mat) {
    
    if(image) {
#if VERSIONMAC
        CGImageToMat(image, mat, false);
#else
        auto format = image->GetPixelFormat();
        if (format == PixelFormat24bppRGB) {
            int w = image->GetWidth();
            int h = image->GetHeight();
            Gdiplus::Rect rcLock(0, 0, w, h);
            Gdiplus::BitmapData bmpData;
            if (image->LockBits(&rcLock, Gdiplus::ImageLockModeRead, format, &bmpData) == Gdiplus::Ok) {
                mat = cv::Mat(h, w, CV_8UC3, static_cast<unsigned char*>(bmpData.Scan0), bmpData.Stride).clone();
                image->UnlockBits(&bmpData);
            }
        }
#endif
    }
}

static void disposeImage(Image image) {
    
    if(image) {
#if VERSIONMAC
        CGImageRelease(image);
#else
        image->operator delete[];
        //image->Dispose();
#endif
    }
}

static Image pictureToImage(PA_Picture p) {
    
    if(!PA_IsCompiled(0))
    {
        return (CGImageRef)PA_CreateNativePictureForScreen(p);
        /* this image needs to be released */
    }else
    {
        Image image = NULL;
        
        //convert picture
        PA_Variable args[3];
        args[0] = PA_CreateVariable(eVK_Picture);
        PA_SetPictureVariable(&args[0], p);
        args[1] = PA_CreateVariable(eVK_Unistring);
        PA_Unistring ustr = PA_CreateUnistring((PA_Unichar *)".\0b\0m\0p\0\0\0");
        PA_SetStringVariable(&args[1], &ustr);
        
        PA_ExecuteCommandByID(CONVERT_PICTURE, args, 2);
        
        p = PA_GetPictureVariable(args[0]);/* the picture has been converted */
        
        PA_SetPictureVariable(&args[0], NULL);
        
        PA_ClearVariable(&args[0]);
        PA_ClearVariable(&args[1]);
        
        PA_Handle h = PA_NewHandle(0);
        
        PA_ErrorCode err = eER_NoErr;
        PA_GetPictureData(p, 1, h);
        err = PA_GetLastError();
        
        if(err == eER_NoErr)
        {
#if VERSIONMAC
            NSData *data = [[NSData alloc]initWithBytes:PA_LockHandle(h) length:PA_GetHandleSize(h)];
            PA_UnlockHandle(h);
            NSImage *_image = [[NSImage alloc]initWithData:data];
            image = [_image CGImageForProposedRect:NULL context:NULL hints:NULL];
            /* this image does NOT need to be released */
            [_image release];
            [data release];
            
            CFRetain(image);/* because we release it in the end */
#else
            IStream *istream = SHCreateMemStream((const BYTE *)PA_LockHandle(h), PA_GetHandleSize(h));
            PA_UnlockHandle(h);
            image = Gdiplus::Bitmap::FromStream(istream);
            istream->Release();
#endif
        }
        
        PA_DisposeHandle(h);
        
        return image;
    }

}

void opencv_decode_qrcode(PA_PluginParameters params) {

    PA_Picture p = PA_GetPictureParameter(params, 1);

    p = PA_DuplicatePicture(p, 1);
    
    PA_ObjectRef status = PA_CreateObject();
    
    cv::Mat mat, straight_qrcode;
    
    Image image = pictureToImage( p);
    
    imageToMat(image, mat);
    
    cv::QRCodeDetector detector;
    
    std::vector<std::string> decoded_info;
    std::vector<cv::Point> points;
    std::vector<cv::Mat> straight_barcodes;
    
    bool success =  detector.detectAndDecodeMulti(mat, decoded_info, points, straight_barcodes);
    
    ob_set_b(status, L"success", success);
    
    if(success) {
        PA_CollectionRef values = PA_CreateCollection();
        for(auto it = decoded_info.begin(); it != decoded_info.end(); ++it) {
            std::string info = *it;
            PA_Variable v = PA_CreateVariable(eVK_Unistring);
            C_TEXT u;
            u.setUTF8String((const uint8_t *)info.c_str(), (uint32_t)info.length());
            PA_Unistring ustr = PA_CreateUnistring((PA_Unichar *)u.getUTF16StringPtr());
            PA_SetStringVariable(&v, &ustr);
            PA_SetCollectionElement(values, PA_GetCollectionLength(values), v);
            PA_ClearVariable(&v);
        }
        ob_set_c(status, L"values", values);
        
        PA_CollectionRef images = PA_CreateCollection();
        for(auto it = straight_barcodes.begin(); it != straight_barcodes.end(); ++it) {
            cv::Mat image = *it;
            std::vector<uchar> buf;
            if(imencode(".png", image, buf)) {
                PA_Picture straight = PA_CreatePicture(&buf[0], (PA_long32)buf.size());
                PA_Variable v = PA_CreateVariable(eVK_Picture);
                PA_SetPictureVariable(&v, straight);
                PA_SetCollectionElement(images, PA_GetCollectionLength(images), v);
                PA_ClearVariable(&v);
            }
        }
        ob_set_c(status, L"images", images);
    }
        
    disposeImage(image);
    
    PA_ReturnObject(params, status);
}

