/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-opencv-qr.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : opencv-qr
 #	author : miyako
 #	2022/06/03
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-opencv-qr.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- opencv-qr
            
			case 1 :
				opencv_decode_qrcode(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

#define CONVERT_PICTURE  (1002)
#define PICTURE_PROPERTIES (457)

#if VERSIONMAC
    typedef CGImageRef Image;
#else
    typedef Gdiplus::Bitmap *Image;
#endif

#if VERSIONWIN
cv::Mat CopyBmpDataToMat(Gdiplus::BitmapData* pi_Data)
	{

		int s32_CvType;
		switch (pi_Data->PixelFormat)
		{
		case PixelFormat1bppIndexed:
		case PixelFormat8bppIndexed:
			// Special case treated separately below
			break;

		case PixelFormat24bppRGB:  // 24 bit
			s32_CvType = CV_8UC3;
			break;

		case PixelFormat32bppRGB:  // 32 bit
		case PixelFormat32bppARGB: // 32 bit + Alpha channel    
			s32_CvType = CV_8UC4;
			break;

		default:
			throw L"Image format not supported.";
		}

		cv::Mat i_Mat;

		if (pi_Data->PixelFormat == PixelFormat1bppIndexed) // 1 bit (special case)
		{
			i_Mat = cv::Mat(pi_Data->Height, pi_Data->Width, CV_8UC1);

			for (UINT Y = 0; Y<pi_Data->Height; Y++)
			{
				BYTE* pu8_Src = (BYTE*)pi_Data->Scan0 + Y * pi_Data->Stride;
				BYTE* pu8_Dst = i_Mat.ptr<BYTE>(Y);

				BYTE u8_Mask = 0x80;
				for (UINT X = 0; X<pi_Data->Width; X++)
				{
					pu8_Dst[0] = (pu8_Src[0] & u8_Mask) ? 255 : 0;
					pu8_Dst++;

					u8_Mask >>= 1;
					if (u8_Mask == 0)
					{
						pu8_Src++;
						u8_Mask = 0x80;
					}
				}
			}
		}
		else if (pi_Data->PixelFormat == PixelFormat8bppIndexed) // 8 bit gray scale palette (special case)
		{
			i_Mat = cv::Mat(pi_Data->Height, pi_Data->Width, CV_8UC1);

			BYTE* u8_Src = (BYTE*)pi_Data->Scan0;
			BYTE* u8_Dst = i_Mat.data;

			for (UINT R = 0; R<pi_Data->Height; R++)
			{
				memcpy(u8_Dst, u8_Src, pi_Data->Width);
				u8_Src += pi_Data->Stride;
				u8_Dst += i_Mat.step;
			}
		}
		else // 24 Bit / 32 Bit
		{
			// Create a Mat pointing to external memory
			cv::Mat i_Ext(pi_Data->Height, pi_Data->Width, s32_CvType, pi_Data->Scan0, pi_Data->Stride);

			// Create a Mat with own memory
			i_Ext.copyTo(i_Mat);
		}
		return i_Mat;
	}
#endif

static void imageToMat(Image image, cv::Mat& mat) {
    
    if(image) {
#if VERSIONMAC
        CGImageToMat(image, mat, false);
#else

		Gdiplus::BitmapData i_Data;
		Gdiplus::Rect k_Rect(0, 0, image->GetWidth(), image->GetHeight());
		if (!image->LockBits(&k_Rect, Gdiplus::ImageLockModeRead, image->GetPixelFormat(), &i_Data)) {
			mat = CopyBmpDataToMat(&i_Data);
			image->UnlockBits(&i_Data);
		}
#endif
    }
}

static void disposeImage(Image image) {
    
    if(image) {
#if VERSIONMAC
        CGImageRelease(image);
#else
        image->operator delete[];
        //image->Dispose();
#endif
    }
}

static Image pictureToImage(PA_Picture p) {
    
    if(!PA_IsCompiled(0)) 
    {
        return (Image)PA_CreateNativePictureForScreen(p);
        /* this image needs to be released */
    }else
    {
        Image image = NULL;
        
        //convert picture
        PA_Variable args[3];
        args[0] = PA_CreateVariable(eVK_Picture);
        PA_SetPictureVariable(&args[0], p);
        args[1] = PA_CreateVariable(eVK_Unistring);
        PA_Unistring ustr = PA_CreateUnistring((PA_Unichar *)".\0b\0m\0p\0\0\0");
        PA_SetStringVariable(&args[1], &ustr);
        
        PA_ExecuteCommandByID(CONVERT_PICTURE, args, 2);
        
        p = PA_GetPictureVariable(args[0]);/* the picture has been converted */
        
        PA_SetPictureVariable(&args[0], NULL);
        
        PA_ClearVariable(&args[0]);
        PA_ClearVariable(&args[1]);
        
        PA_Handle h = PA_NewHandle(0);
        
        PA_ErrorCode err = eER_NoErr;
        PA_GetPictureData(p, 1, h);
        err = PA_GetLastError();
        
        if(err == eER_NoErr)
        {
#if VERSIONMAC
            NSData *data = [[NSData alloc]initWithBytes:PA_LockHandle(h) length:PA_GetHandleSize(h)];
            PA_UnlockHandle(h);
            NSImage *_image = [[NSImage alloc]initWithData:data];
            image = [_image CGImageForProposedRect:NULL context:NULL hints:NULL];
            /* this image does NOT need to be released */
            [_image release];
            [data release];
            
            CFRetain(image);/* because we release it in the end */
#else
            IStream *istream = SHCreateMemStream((const BYTE *)PA_LockHandle(h), PA_GetHandleSize(h));
            PA_UnlockHandle(h);
            image = Gdiplus::Bitmap::FromStream(istream);
            istream->Release();
#endif
        }
        
        PA_DisposeHandle(h);
        
        return image;
    }

}

void opencv_decode_qrcode(PA_PluginParameters params) {

    PA_Picture p = PA_GetPictureParameter(params, 1);

    p = PA_DuplicatePicture(p, 1);
    
    PA_ObjectRef status = PA_CreateObject();
    
    cv::Mat mat, straight_qrcode;
    
    Image image = pictureToImage( p);
    
    imageToMat(image, mat);
    
    cv::QRCodeDetector detector;
    
    std::vector<std::string> decoded_info;
    std::vector<cv::Point> points;
    std::vector<cv::Mat> straight_barcodes;
    
    bool success =  detector.detectAndDecodeMulti(mat, decoded_info, points, straight_barcodes);
    
    ob_set_b(status, L"success", success);
    
    if(success) {
        PA_CollectionRef values = PA_CreateCollection();
        for(auto it = decoded_info.begin(); it != decoded_info.end(); ++it) {
            std::string info = *it;
            PA_Variable v = PA_CreateVariable(eVK_Unistring);
            C_TEXT u;
            u.setUTF8String((const uint8_t *)info.c_str(), (uint32_t)info.length());
            PA_Unistring ustr = PA_CreateUnistring((PA_Unichar *)u.getUTF16StringPtr());
            PA_SetStringVariable(&v, &ustr);
            PA_SetCollectionElement(values, PA_GetCollectionLength(values), v);
            PA_ClearVariable(&v);
        }
        ob_set_c(status, L"values", values);
        
        PA_CollectionRef images = PA_CreateCollection();
        for(auto it = straight_barcodes.begin(); it != straight_barcodes.end(); ++it) {
            cv::Mat image = *it;
            std::vector<uchar> buf;
            if(imencode(".png", image, buf)) {
                PA_Picture straight = PA_CreatePicture(&buf[0], (PA_long32)buf.size());
                PA_Variable v = PA_CreateVariable(eVK_Picture);
                PA_SetPictureVariable(&v, straight);
                PA_SetCollectionElement(images, PA_GetCollectionLength(images), v);
                PA_ClearVariable(&v);
            }
        }
        ob_set_c(status, L"images", images);
    }
        
    disposeImage(image);
    
    PA_ReturnObject(params, status);
}

